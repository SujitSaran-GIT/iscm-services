# ========== Server / Context Path ==========
server.port = 8081
server.servlet.context-path = /iam

# ========== Application Name ==========
spring.application.name = iam-service

# ========== Datasource / PostgreSQL / Hikari ==========
spring.datasource.url = ${DB_URL:jdbc:postgresql://localhost:5432/iscm_iam}
spring.datasource.username = ${DB_USERNAME:postgres}
spring.datasource.password = ${DB_PASSWORD:Saran@2002}
spring.datasource.driver-class-name = org.postgresql.Driver

# ========== Optimized HikariCP Connection Pooling ==========
spring.datasource.hikari.maximum-pool-size = 20
spring.datasource.hikari.minimum-idle = 5
spring.datasource.hikari.connection-timeout = 20000
spring.datasource.hikari.idle-timeout = 300000
spring.datasource.hikari.max-lifetime = 1200000
spring.datasource.hikari.leak-detection-threshold = 60000

# Advanced HikariCP settings for production performance
spring.datasource.hikari.pool-name = ISCM-IAM-HikariPool
spring.datasource.hikari.validation-timeout = 3000
spring.datasource.hikari.connection-test-query = SELECT 1
spring.datasource.hikari.initialization-fail-timeout = 60000

# Performance optimization settings
spring.datasource.hikari.register-mbeans = true
spring.datasource.hikari.allow-pool-suspension = false
spring.datasource.hikari.read-only = false
spring.datasource.hikari.auto-commit = true

# ========== JPA / Hibernate ==========
spring.jpa.hibernate.ddl-auto = validate
spring.jpa.show-sql = false
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql = true
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation = true

# ========== Optimized Hibernate Performance Settings ==========
spring.jpa.properties.hibernate.jdbc.batch_size = 50
spring.jpa.properties.hibernate.order_inserts = true
spring.jpa.properties.hibernate.order_updates = true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data = true
spring.jpa.properties.hibernate.jdbc.fetch_size = 100
spring.jpa.properties.hibernate.default_batch_fetch_size = 20

# Connection and query optimization
spring.jpa.properties.hibernate.connection.provider_disables_autocommit = true
spring.jpa.properties.hibernate.jdbc.use_get_generated_keys = true
spring.jpa.properties.hibernate.use_sql_comments = true

# Performance tuning
spring.jpa.properties.hibernate.connection.handling_mode = DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT
spring.jpa.properties.hibernate.id.optimizer.pooled = true

# Statistics for monitoring
spring.jpa.properties.hibernate.generate_statistics = true
spring.jpa.properties.hibernate.session.events.log.LOG_QUERIES_SLOWER_THAN_MS = 100

# ========== Liquibase (migrations) ==========
spring.liquibase.change-log = classpath:db/changelog/db.changelog.master.yaml
spring.liquibase.enabled = false

# ========== Redis (Optimized Configuration) ==========
spring.data.redis.host = ${REDIS_HOST:localhost}
spring.data.redis.port = ${REDIS_PORT:6379}
spring.data.redis.password = ${REDIS_PASSWORD:}
spring.data.redis.database = 0
spring.data.redis.timeout = 3000ms

# ========== Redis Connection Pooling ==========
spring.data.redis.lettuce.pool.max-active = 20
spring.data.redis.lettuce.pool.max-idle = 10
spring.data.redis.lettuce.pool.min-idle = 5
spring.data.redis.lettuce.pool.max-wait = 3000ms

# Redis performance optimizations
spring.data.redis.lettuce.shutdown-timeout = 100ms
spring.data.redis.lettuce.cluster.refresh.adaptive = true
spring.data.redis.lettuce.cluster.refresh.period = 30s

# ========== Mail settings ==========
spring.mail.host = ${MAIL_HOST:localhost}
spring.mail.port = ${MAIL_PORT:1025}
spring.mail.properties.mail.smtp.auth = false
spring.mail.properties.mail.smtp.starttls.enable = false

# ========== JWT & Security ==========
app.jwt.secret = ${JWT_SECRET:mySecretKey123456789012345678901234567890}
app.jwt.refresh-secret = ${JWT_REFRESH_SECRET:myRefreshSecretKey123456789012345678901234567890}
app.jwt.expiration.access = 900
app.jwt.expiration.refresh = 604800

app.security.max-login-attempts = 5
app.security.account-lock-duration-minutes = 30

# ========== OAuth Configuration ==========
app.oauth.google.client-id = ${GOOGLE_CLIENT_ID:placeholder-client-id}
app.oauth.google.client-secret = ${GOOGLE_CLIENT_SECRET:placeholder-client-secret}
app.oauth.google.redirect-uri = ${GOOGLE_REDIRECT_URI:http://localhost:8081/iam/api/v1/oauth/google/callback}

app.oauth.microsoft.client-id = ${MICROSOFT_CLIENT_ID:placeholder-client-id}
app.oauth.microsoft.client-secret = ${MICROSOFT_CLIENT_SECRET:placeholder-client-secret}
app.oauth.microsoft.redirect-uri = ${MICROSOFT_REDIRECT_URI:http://localhost:8081/iam/api/v1/oauth/microsoft/callback}

app.oauth.linkedin.client-id = ${LINKEDIN_CLIENT_ID:placeholder-client-id}
app.oauth.linkedin.client-secret = ${LINKEDIN_CLIENT_SECRET:placeholder-client-secret}
app.oauth.linkedin.redirect-uri = ${LINKEDIN_REDIRECT_URI:http://localhost:8081/iam/api/v1/oauth/linkedin/callback}

# ========== Fraud Detection ==========
app.fraud.service.url = ${FRAUD_SERVICE_URL:http://localhost:8082}

# ========== MFA Configuration ==========
app.mfa.totp.window-size = 3
app.mfa.backup-codes.count = 10

# ========== Device Management ==========
app.device.max-trusted-devices = 5

# ========== Logging ==========
logging.level.com.iscm = DEBUG
logging.level.org.springframework.security = INFO
logging.level.org.hibernate.SQL = WARN
logging.pattern.console = %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# ========== Actuator / Management ==========
management.endpoints.web.exposure.include = health,info,metrics,prometheus,beans,env,mappings,threaddump,loggers
management.endpoints.web.base-path = /actuator
management.endpoint.health.show-details = always
management.endpoint.health.show-components = always
management.endpoint.metrics.enabled = true
management.endpoint.prometheus.enabled = true

# Disable mail health check as it's not required for core functionality
management.health.mail.enabled = false

# ========== Springdoc / OpenAPI ==========
springdoc.api-docs.path = /v3/api-docs
springdoc.swagger-ui.path = /swagger-ui.html
springdoc.swagger-ui.operations-sorter = method
springdoc.swagger-ui.tags-sorter = alpha

# ========== Security Monitoring ==========
app.security.monitoring.enabled = true
app.security.monitoring.alert-threshold-failed-logins = 10
app.security.monitoring.alert-threshold-suspicious-activities = 20
app.security.monitoring.window-minutes = 60

# ========== Rate Limiting ==========
app.security.rate-limiting.enabled = true
app.security.rate-limiting.max-attempts = 5
app.security.rate-limiting.window-seconds = 60
app.security.rate-limiting.global.max-requests = 1000
app.security.rate-limiting.global.window-seconds = 60

# ========== JWT Blacklist ==========
app.jwt.blacklist.enabled = true
app.jwt.blacklist.cleanup-interval = 3600
app.jwt.blacklist.max-size = 10000

# ========== Cache Configuration ==========
app.cache.enabled = true
app.cache.stats.enabled = true
spring.cache.type = redis
spring.cache.redis.time-to-live = 1800000 # 30 minutes default TTL
spring.cache.redis.cache-null-values = false
spring.cache.redis.use-key-prefix = true
spring.cache.redis.key-prefix = iscm.iam.

# ========== Session Management Configuration ==========
app.session.max-concurrent-sessions = 5
app.session.cleanup.threshold = 100
app.session.timeout = 604800 # 7 days in seconds
app.session.validation.interval = 300 # 5 minutes

# ========== Async Processing Configuration ==========
app.async.core-pool-size = 5
app.async.max-pool-size = 20
app.async.queue-capacity = 100
app.async.thread-name-prefix = iscm-async-

# ========== Email Configuration ==========
app.email.enabled = false
app.email.from = noreply@iscm.com
app.email.base-url = http://localhost:3000

# ========== Horizontal Scaling Configuration ==========
app.scaling.enabled = true
app.scaling.session.prefix = session:
app.scaling.session.timeout = 3600
app.scaling.session.cookie-name = ISCMSESSION
app.scaling.session.cookie-domain =
app.scaling.session.cookie-secure = true
app.scaling.session.cookie-same-site = Lax
app.scaling.session.cookie-http-only = true
app.scaling.session.cleanup-interval = 300

# ========== Distributed Cache Configuration ==========
app.scaling.distributed-cache.enabled = true

# ========== Service Discovery Configuration ==========
app.scaling.service-discovery.enabled = true
app.scaling.instance-id = ${HOSTNAME:localhost}:${server.port:8081}
app.scaling.health-check.interval = 30000

# ========== Metrics Configuration ==========
app.scaling.metrics.enabled = true

# ========== Cluster Coordination Configuration ==========
app.scaling.cluster-coordination.enabled = true
app.scaling.health-check.enabled = true

# ========== Database Read Replica Configuration ==========
app.database.read-replica.enabled = true
app.database.read-replica.cache.enabled = true
app.database.read-replica.cache.ttl = 300

# Primary Database Configuration
app.database.primary.url = ${DB_URL:jdbc:postgresql://localhost:5432/iscm_iam}
app.database.primary.username = ${DB_USERNAME:postgres}
app.database.primary.password = ${DB_PASSWORD:password}
app.database.primary.driver-class-name = org.postgresql.Driver

# Read Replica Database Configuration
app.database.read-replica.url = ${DB_READ_REPLICA_URL:jdbc:postgresql://localhost:5433/iscm_iam}
app.database.read-replica.username = ${DB_READ_REPLICA_USERNAME:postgres}
app.database.read-replica.password = ${DB_READ_REPLICA_PASSWORD:password}
app.database.read-replica.driver-class-name = org.postgresql.Driver

# ========== AUTO-SCALING CONFIGURATION ==========
app.auto-scaling.enabled = true
app.auto-scaling.evaluation.interval = 30000

# Instance Limits
app.auto-scaling.min.instances = 2
app.auto-scaling.max.instances = 10

# CPU Thresholds (percentage)
app.auto-scaling.cpu.threshold.scale-up = 75
app.auto-scaling.cpu.threshold.scale-down = 35

# Memory Thresholds (percentage)
app.auto-scaling.memory.threshold.scale-up = 85
app.auto-scaling.memory.threshold.scale-down = 45

# Database Connection Thresholds
app.auto-scaling.db-connection.threshold.scale-up = 80
app.auto-scaling.db-connection.threshold.scale-down = 30

# Cache Hit Rate Thresholds (percentage)
app.auto-scaling.cache-hit-rate.threshold.scale-down = 70

# Request Rate Thresholds (requests per second)
app.auto-scaling.request-rate.threshold.scale-up = 150
app.auto-scaling.request-rate.threshold.scale-down = 25

# Response Time Thresholds (milliseconds)
app.auto-scaling.response-time.threshold.scale-up = 1500
app.auto-scaling.response-time.threshold.scale-down = 400

# Cooldown Period (seconds)
app.auto-scaling.cooldown-period = 300

# Auto-scaling Strategy Configuration
app.auto-scaling.strategy = composite-metrics
app.auto-scaling.decision-engine = weighted-composite
app.auto-scaling.metrics.window = 60
app.auto-scaling.prediction.enabled = false

# Advanced Auto-scaling Settings
app.auto-scaling.graceful-shutdown.enabled = true
app.auto-scaling.health-check.during-scaling = true
app.auto-scaling.rolling-update.enabled = true
app.auto-scaling.prediction.model = linear-regression

# Auto-scaling Metrics Collection
app.auto-scaling.metrics.collection.enabled = true
app.auto-scaling.metrics.retention.hours = 168
app.auto-scaling.metrics.aggregation.interval = 10

# Auto-scaling Notifications
app.auto-scaling.notifications.enabled = true
app.auto-scaling.notifications.channels = webhook,email
app.auto-scaling.notifications.webhook.url = ${WEBHOOK_URL:http://localhost:8080/webhooks/autoscaling}

# JVM-specific Auto-scaling Metrics
app.auto-scaling.jvm.heap-usage.scale-up = 85
app.auto-scaling.jvm.heap-usage.scale-down = 40
app.auto-scaling.jvm.gc-frequency.scale-up = 10
app.auto-scaling.jvm.gc-frequency.scale-down = 2
