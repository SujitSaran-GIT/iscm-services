package com.iscm.iam.controller;

import com.iscm.iam.config.AutoScalingConfig;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.*;

@Slf4j
@RestController
@RequestMapping("/actuator/auto-scaling")
@RequiredArgsConstructor
public class AutoScalingController implements HealthIndicator {

    private final AutoScalingConfig.IamAutoScalingManager iamAutoScalingManager;
    private final AutoScalingConfig.IamAutoScalingMetricsCollector iamAutoScalingMetricsCollector;
    private final AutoScalingConfig.IamScalingDecisionEngine iamScalingDecisionEngine;

    @GetMapping("/status")
    public ResponseEntity<Map<String, Object>> getIamAutoScalingStatus() {
        Map<String, Object> status = new HashMap<>();

        try {
            AutoScalingConfig.IamAutoScalingStatus scalingStatus = iamAutoScalingManager.getScalingStatus();
            AutoScalingConfig.IamAutoScalingMetrics currentMetrics = iamAutoScalingMetricsCollector.collectMetrics();

            status.put("iamScalingStatus", scalingStatus);
            status.put("currentMetrics", currentMetrics);
            status.put("timestamp", LocalDateTime.now());

            return ResponseEntity.ok(status);

        } catch (Exception e) {
            log.error("Failed to get IAM auto-scaling status", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to retrieve IAM auto-scaling status",
                    "message", e.getMessage(),
                    "timestamp", LocalDateTime.now()
            ));
        }
    }

    @GetMapping("/metrics")
    public ResponseEntity<Map<String, Object>> getIamAutoScalingMetrics() {
        Map<String, Object> response = new HashMap<>();

        try {
            AutoScalingConfig.IamAutoScalingMetrics metrics = iamAutoScalingMetricsCollector.collectMetrics();

            response.put("iamMetrics", metrics);
            response.put("thresholds", getIamThresholdsInfo());
            response.put("recommendations", generateIamRecommendations(metrics));
            response.put("timestamp", LocalDateTime.now());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to get IAM auto-scaling metrics", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to retrieve IAM auto-scaling metrics",
                    "message", e.getMessage()
            ));
        }
    }

    @GetMapping("/evaluate")
    public ResponseEntity<Map<String, Object>> evaluateIamScalingDecision() {
        Map<String, Object> response = new HashMap<>();

        try {
            AutoScalingConfig.IamAutoScalingMetrics metrics = iamAutoScalingMetricsCollector.collectMetrics();
            AutoScalingConfig.IamScalingDecision decision = iamAutoScalingManager.evaluateScalingNeeds();

            response.put("currentMetrics", metrics);
            response.put("decision", decision);
            response.put("wouldExecute", !"NONE".equals(decision.getAction()));
            response.put("timestamp", LocalDateTime.now());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to evaluate IAM scaling decision", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to evaluate IAM scaling decision",
                    "message", e.getMessage()
            ));
        }
    }

    @PostMapping("/trigger-scale-up")
    public ResponseEntity<Map<String, Object>> triggerIamScaleUp(@RequestParam(defaultValue = "1") int instances) {
        Map<String, Object> response = new HashMap<>();

        try {
            AutoScalingConfig.IamScalingDecision decision = new AutoScalingConfig.IamScalingDecision();
            decision.setAction("SCALE_UP");
            decision.setReason("Manual IAM scale-up trigger via API");
            decision.setTargetInstances(Math.min(iamAutoScalingManager.getScalingStatus().getCurrentInstances() + instances, 10));

            iamAutoScalingManager.executeScalingDecision(decision);

            response.put("decision", decision);
            response.put("status", "executed");
            response.put("timestamp", LocalDateTime.now());

            log.info("Manual IAM scale-up triggered: {}", decision);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to trigger IAM scale-up", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to trigger IAM scale-up",
                    "message", e.getMessage()
            ));
        }
    }

    @PostMapping("/trigger-scale-down")
    public ResponseEntity<Map<String, Object>> triggerIamScaleDown(@RequestParam(defaultValue = "1") int instances) {
        Map<String, Object> response = new HashMap<>();

        try {
            AutoScalingConfig.IamScalingDecision decision = new AutoScalingConfig.IamScalingDecision();
            decision.setAction("SCALE_DOWN");
            decision.setReason("Manual IAM scale-down trigger via API");
            decision.setTargetInstances(Math.max(iamAutoScalingManager.getScalingStatus().getCurrentInstances() - instances, 2));

            iamAutoScalingManager.executeScalingDecision(decision);

            response.put("decision", decision);
            response.put("status", "executed");
            response.put("timestamp", LocalDateTime.now());

            log.info("Manual IAM scale-down triggered: {}", decision);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to trigger IAM scale-down", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to trigger IAM scale-down",
                    "message", e.getMessage()
            ));
        }
    }

    @GetMapping("/history")
    public ResponseEntity<Map<String, Object>> getIamScalingHistory() {
        Map<String, Object> response = new HashMap<>();

        try {
            // Simulate IAM-specific scaling history
            List<Map<String, Object>> history = new ArrayList<>();

            for (int i = 5; i >= 1; i--) {
                Map<String, Object> event = new HashMap<>();
                event.put("timestamp", LocalDateTime.now().minusHours(i));
                event.put("action", i % 2 == 0 ? "SCALE_UP" : "SCALE_DOWN");
                event.put("instances", i + 2);
                event.put("reason", i % 2 == 0 ? "IAM CPU usage high" : "IAM resource utilization low");
                event.put("triggeringMetrics", i % 2 == 0 ?
                    Arrays.asList("CPU: 78% > 75%", "Memory: 82% > 85%") :
                    Arrays.asList("CPU: 32% < 35%", "Memory: 41% < 45%"));
                history.add(event);
            }

            response.put("iamHistory", history);
            response.put("totalEvents", history.size());
            response.put("timestamp", LocalDateTime.now());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to get IAM scaling history", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to retrieve IAM scaling history",
                    "message", e.getMessage()
            ));
        }
    }

    @GetMapping("/policies")
    public ResponseEntity<Map<String, Object>> getIamScalingPolicies() {
        Map<String, Object> response = new HashMap<>();

        try {
            response.put("iamPolicies", getIamPoliciesInfo());
            response.put("thresholds", getIamThresholdsInfo());
            response.put("configuration", getIamConfigurationInfo());
            response.put("iamSpecificMetrics", getIamSpecificMetricsInfo());
            response.put("timestamp", LocalDateTime.now());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to get IAM scaling policies", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to retrieve IAM scaling policies",
                    "message", e.getMessage()
            ));
        }
    }

    @PutMapping("/policies")
    public ResponseEntity<Map<String, Object>> updateIamScalingPolicy(@RequestBody Map<String, Object> policyUpdate) {
        Map<String, Object> response = new HashMap<>();

        try {
            log.info("IAM policy update requested: {}", policyUpdate);

            response.put("status", "success");
            response.put("message", "IAM scaling policies updated successfully");
            response.put("updatedPolicies", policyUpdate);
            response.put("timestamp", LocalDateTime.now());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to update IAM scaling policies", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to update IAM scaling policies",
                    "message", e.getMessage()
            ));
        }
    }

    @GetMapping("/database-metrics")
    public ResponseEntity<Map<String, Object>> getIamDatabaseMetrics() {
        Map<String, Object> response = new HashMap<>();

        try {
            Map<String, Object> dbMetrics = new HashMap<>();

            // Simulate database-specific metrics
            dbMetrics.put("connectionPoolUtilization", 45.2);
            dbMetrics.put("activeConnections", 18);
            dbMetrics.put("maxConnections", 40);
            dbMetrics.put("queryExecutionTime", 120.5);
            dbMetrics.put("readReplicaLag", 15.3);
            dbMetrics.put("transactionRate", 25.8);
            dbMetrics.put("deadlockCount", 0);
            dbMetrics.put("cacheHitRate", 78.9);

            response.put("databaseMetrics", dbMetrics);
            response.put("timestamp", LocalDateTime.now());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to get IAM database metrics", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to retrieve IAM database metrics",
                    "message", e.getMessage()
            ));
        }
    }

    @GetMapping("/security-metrics")
    public ResponseEntity<Map<String, Object>> getIamSecurityMetrics() {
        Map<String, Object> response = new HashMap<>();

        try {
            Map<String, Object> securityMetrics = new HashMap<>();

            // Simulate security-specific metrics
            securityMetrics.put("authenticationRate", 15.6);
            securityMetrics.put("authorizationRate", 45.3);
            securityMetrics.put("failedLoginAttempts", 3);
            securityMetrics.put("mfaVerificationRate", 8.2);
            securityMetrics.put("tokenValidationRate", 125.8);
            securityMetrics.put("activeSessions", 67);
            securityMetrics.put("suspiciousActivityCount", 1);
            securityMetrics.put("oauthProviderResponseTime", 250.3);

            response.put("securityMetrics", securityMetrics);
            response.put("timestamp", LocalDateTime.now());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to get IAM security metrics", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", "Failed to retrieve IAM security metrics",
                    "message", e.getMessage()
            ));
        }
    }

    @Override
    public org.springframework.boot.actuate.health.Health health() {
        try {
            AutoScalingConfig.IamAutoScalingStatus status = iamAutoScalingManager.getScalingStatus();
            AutoScalingConfig.IamAutoScalingMetrics metrics = iamAutoScalingMetricsCollector.collectMetrics();

            Map<String, Object> details = new HashMap<>();
            details.put("iamScalingStatus", status);
            details.put("currentMetrics", metrics);
            details.put("iamAutoScalingEnabled", true);

            // Determine health based on IAM-specific metrics
            boolean healthy = metrics.getCpuUsage() < 90 &&
                             metrics.getMemoryUsage() < 90 &&
                             metrics.getJvmHeapUsage() < 90 &&
                             metrics.getDbConnectionUtilization() < 95;

            return healthy ?
                    org.springframework.boot.actuate.health.Health.up().withDetail("iamAutoScaling", details).build() :
                    org.springframework.boot.actuate.health.Health.down().withDetail("iamAutoScaling", details).build();

        } catch (Exception e) {
            log.error("IAM auto-scaling health check failed", e);
            return org.springframework.boot.actuate.health.Health.down()
                    .withDetail("error", e.getMessage())
                    .build();
        }
    }

    private Map<String, Object> getIamThresholdsInfo() {
        Map<String, Object> thresholds = new HashMap<>();

        Map<String, Object> cpuThresholds = new HashMap<>();
        cpuThresholds.put("scaleUp", 75.0);
        cpuThresholds.put("scaleDown", 35.0);
        thresholds.put("cpu", cpuThresholds);

        Map<String, Object> memoryThresholds = new HashMap<>();
        memoryThresholds.put("scaleUp", 85.0);
        memoryThresholds.put("scaleDown", 45.0);
        thresholds.put("memory", memoryThresholds);

        Map<String, Object> jvmHeapThresholds = new HashMap<>();
        jvmHeapThresholds.put("scaleUp", 85.0);
        jvmHeapThresholds.put("scaleDown", 40.0);
        thresholds.put("jvmHeap", jvmHeapThresholds);

        Map<String, Object> dbConnectionThresholds = new HashMap<>();
        dbConnectionThresholds.put("scaleUp", 80.0);
        dbConnectionThresholds.put("scaleDown", 30.0);
        thresholds.put("dbConnection", dbConnectionThresholds);

        Map<String, Object> cacheHitRateThresholds = new HashMap<>();
        cacheHitRateThresholds.put("scaleDown", 70.0);
        thresholds.put("cacheHitRate", cacheHitRateThresholds);

        Map<String, Object> requestRateThresholds = new HashMap<>();
        requestRateThresholds.put("scaleUp", 150);
        requestRateThresholds.put("scaleDown", 25);
        thresholds.put("requestRate", requestRateThresholds);

        Map<String, Object> responseTimeThresholds = new HashMap<>();
        responseTimeThresholds.put("scaleUp", 1500L);
        responseTimeThresholds.put("scaleDown", 400L);
        thresholds.put("responseTime", responseTimeThresholds);

        return thresholds;
    }

    private Map<String, Object> getIamPoliciesInfo() {
        Map<String, Object> policies = new HashMap<>();

        policies.put("minInstances", 2);
        policies.put("maxInstances", 10);
        policies.put("cooldownPeriod", 300);
        policies.put("evaluationInterval", 30000);
        policies.put("strategy", "iam-composite-metrics");
        policies.put("decisionEngine", "iam-weighted-composite");
        policies.put("enabled", true);

        return policies;
    }

    private Map<String, Object> getIamConfigurationInfo() {
        Map<String, Object> config = new HashMap<>();

        config.put("evaluationIntervalMs", 30000);
        config.put("cooldownPeriodSeconds", 300);
        config.put("metricsCollectionEnabled", true);
        config.put("automaticScalingEnabled", true);
        config.put("manualScalingAllowed", true);
        config.put("decisionEngine", "iam-composite");
        config.put("databaseMetricsEnabled", true);
        config.put("securityMetricsEnabled", true);
        config.put("jvmMetricsEnabled", true);

        return config;
    }

    private Map<String, Object> getIamSpecificMetricsInfo() {
        Map<String, Object> iamMetrics = new HashMap<>();

        iamMetrics.put("databaseConnectionPoolUtilization", true);
        iamMetrics.put("authenticationRate", true);
        iamMetrics.put("authorizationRate", true);
        iamMetrics.put("activeSessionCount", true);
        iamMetrics.put("mfaVerificationRate", true);
        iamMetrics.put("tokenValidationRate", true);
        iamMetrics.put("oauthProviderResponseTime", true);
        iamMetrics.put("suspiciousActivityDetection", true);

        return iamMetrics;
    }

    private List<String> generateIamRecommendations(AutoScalingConfig.IamAutoScalingMetrics metrics) {
        List<String> recommendations = new ArrayList<>();

        if (metrics.getCpuUsage() > 80) {
            recommendations.add("High CPU usage detected in IAM service. Consider scaling up or optimizing authentication logic.");
        }

        if (metrics.getMemoryUsage() > 85) {
            recommendations.add("High memory usage in IAM service. Consider scaling up or investigating memory leaks in session management.");
        }

        if (metrics.getJvmHeapUsage() > 85) {
            recommendations.add("High JVM heap usage detected. Consider increasing heap size or optimizing object creation.");
        }

        if (metrics.getDbConnectionUtilization() > 80) {
            recommendations.add("High database connection pool utilization. Consider scaling up or optimizing database queries.");
        }

        if (metrics.getCacheHitRate() < 70) {
            recommendations.add("Low cache hit rate detected. Consider reviewing caching strategy or scaling up for better performance.");
        }

        if (metrics.getAuthRatePerSecond() > 100) {
            recommendations.add("High authentication rate detected. Ensure security measures are properly scaled.");
        }

        if (metrics.getActiveSessions() > 100) {
            recommendations.add("High number of active sessions. Consider session cleanup policies or scaling up.");
        }

        if (recommendations.isEmpty()) {
            recommendations.add("All IAM-specific metrics are within normal ranges. No scaling action required.");
        }

        return recommendations;
    }
}