package com.iscm.iam.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import javax.sql.DataSource;
import java.time.LocalDateTime;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
@Configuration
@EnableScheduling
@ConditionalOnProperty(name = "app.auto-scaling.enabled", havingValue = "true", matchIfMissing = true)
public class AutoScalingConfig {

    @Value("${app.auto-scaling.cpu.threshold.scale-up:75}")
    private double cpuScaleUpThreshold;

    @Value("${app.auto-scaling.cpu.threshold.scale-down:35}")
    private double cpuScaleDownThreshold;

    @Value("${app.auto-scaling.memory.threshold.scale-up:85}")
    private double memoryScaleUpThreshold;

    @Value("${app.auto-scaling.memory.threshold.scale-down:45}")
    private double memoryScaleDownThreshold;

    @Value("${app.auto-scaling.db-connection.threshold.scale-up:80}")
    private double dbConnectionScaleUpThreshold;

    @Value("${app.auto-scaling.db-connection.threshold.scale-down:30}")
    private double dbConnectionScaleDownThreshold;

    @Value("${app.auto-scaling.cache-hit-rate.threshold.scale-down:70}")
    private double cacheHitRateScaleDownThreshold;

    @Value("${app.auto-scaling.request-rate.threshold.scale-up:150}")
    private int requestRateScaleUpThreshold;

    @Value("${app.auto-scaling.request-rate.threshold.scale-down:25}")
    private int requestRateScaleDownThreshold;

    @Value("${app.auto-scaling.response-time.threshold.scale-up:1500}")
    private long responseTimeScaleUpThreshold;

    @Value("${app.auto-scaling.response-time.threshold.scale-down:400}")
    private long responseTimeScaleDownThreshold;

    @Value("${app.auto-scaling.jvm.heap-usage.scale-up:85}")
    private double jvmHeapScaleUpThreshold;

    @Value("${app.auto-scaling.jvm.heap-usage.scale-down:40}")
    private double jvmHeapScaleDownThreshold;

    @Value("${app.auto-scaling.min.instances:2}")
    private int minInstances;

    @Value("${app.auto-scaling.max.instances:10}")
    private int maxInstances;

    @Value("${app.auto-scaling.cooldown-period:300}")
    private int cooldownPeriodSeconds;

    private final AtomicInteger currentInstanceCount = new AtomicInteger(2);
    private final ConcurrentHashMap<String, LocalDateTime> lastScaleActions = new ConcurrentHashMap<>();
    private final IamMetricsCollector metricsCollector = new IamMetricsCollector();

    public AutoScalingConfig(DataSource dataSource, RedisTemplate<String, Object> redisTemplate) {
        // Constructor for dependency injection
    }

    @Bean
    public IamAutoScalingManager iamAutoScalingManager() {
        return new IamAutoScalingManager();
    }

    @Bean
    public IamAutoScalingMetricsCollector iamAutoScalingMetricsCollector() {
        return new IamAutoScalingMetricsCollector();
    }

    @Bean
    public IamScalingDecisionEngine iamScalingDecisionEngine() {
        return new IamScalingDecisionEngine();
    }

    public class IamAutoScalingManager {

        public IamScalingDecision evaluateScalingNeeds() {
            IamAutoScalingMetrics metrics = metricsCollector.collectMetrics();
            IamScalingDecision decision = new IamScalingDecision();

            // Check cooldown period
            if (!isCooldownPeriodExpired()) {
                decision.setAction("NONE");
                decision.setReason("Cooldown period active");
                return decision;
            }

            // Evaluate scale-up conditions
            if (shouldScaleUp(metrics)) {
                decision.setAction("SCALE_UP");
                decision.setReason("IAM performance thresholds exceeded");
                decision.setTargetInstances(Math.min(currentInstanceCount.get() + 1, maxInstances));
                decision.setTriggeringMetrics(getTriggeringMetrics(metrics, true));
                return decision;
            }

            // Evaluate scale-down conditions
            if (shouldScaleDown(metrics)) {
                decision.setAction("SCALE_DOWN");
                decision.setReason("IAM performance thresholds below minimum");
                decision.setTargetInstances(Math.max(currentInstanceCount.get() - 1, minInstances));
                decision.setTriggeringMetrics(getTriggeringMetrics(metrics, false));
                return decision;
            }

            decision.setAction("NONE");
            decision.setReason("No scaling needed");
            return decision;
        }

        public void executeScalingDecision(IamScalingDecision decision) {
            if (!"NONE".equals(decision.getAction())) {
                log.info("Executing IAM scaling decision: {} - {}", decision.getAction(), decision.getReason());

                // Simulate scaling action
                simulateIamScalingAction(decision);

                lastScaleActions.put(decision.getAction(), LocalDateTime.now());
                currentInstanceCount.set(decision.getTargetInstances());

                // Notify other systems about scaling event
                notifyScalingEvent(decision);
            }
        }

        private boolean shouldScaleUp(IamAutoScalingMetrics metrics) {
            return currentInstanceCount.get() < maxInstances && (
                metrics.getCpuUsage() > cpuScaleUpThreshold ||
                metrics.getMemoryUsage() > memoryScaleUpThreshold ||
                metrics.getJvmHeapUsage() > jvmHeapScaleUpThreshold ||
                metrics.getDbConnectionUtilization() > dbConnectionScaleUpThreshold ||
                metrics.getRequestRatePerSecond() > requestRateScaleUpThreshold ||
                metrics.getAverageResponseTime() > responseTimeScaleUpThreshold
            );
        }

        private boolean shouldScaleDown(IamAutoScalingMetrics metrics) {
            return currentInstanceCount.get() > minInstances && (
                metrics.getCpuUsage() < cpuScaleDownThreshold &&
                metrics.getMemoryUsage() < memoryScaleDownThreshold &&
                metrics.getJvmHeapUsage() < jvmHeapScaleDownThreshold &&
                metrics.getDbConnectionUtilization() < dbConnectionScaleDownThreshold &&
                metrics.getCacheHitRate() > cacheHitRateScaleDownThreshold &&
                metrics.getRequestRatePerSecond() < requestRateScaleDownThreshold &&
                metrics.getAverageResponseTime() < responseTimeScaleDownThreshold
            );
        }

        private java.util.List<String> getTriggeringMetrics(IamAutoScalingMetrics metrics, boolean scaleUp) {
            java.util.List<String> triggeringMetrics = new java.util.ArrayList<>();

            if (scaleUp) {
                if (metrics.getCpuUsage() > cpuScaleUpThreshold) {
                    triggeringMetrics.add(String.format("CPU: %.1f%% > %.1f%%", metrics.getCpuUsage(), cpuScaleUpThreshold));
                }
                if (metrics.getMemoryUsage() > memoryScaleUpThreshold) {
                    triggeringMetrics.add(String.format("Memory: %.1f%% > %.1f%%", metrics.getMemoryUsage(), memoryScaleUpThreshold));
                }
                if (metrics.getJvmHeapUsage() > jvmHeapScaleUpThreshold) {
                    triggeringMetrics.add(String.format("JVM Heap: %.1f%% > %.1f%%", metrics.getJvmHeapUsage(), jvmHeapScaleUpThreshold));
                }
                if (metrics.getDbConnectionUtilization() > dbConnectionScaleUpThreshold) {
                    triggeringMetrics.add(String.format("DB Connections: %.1f%% > %.1f%%", metrics.getDbConnectionUtilization(), dbConnectionScaleUpThreshold));
                }
            } else {
                if (metrics.getCpuUsage() < cpuScaleDownThreshold) {
                    triggeringMetrics.add(String.format("CPU: %.1f%% < %.1f%%", metrics.getCpuUsage(), cpuScaleDownThreshold));
                }
                if (metrics.getMemoryUsage() < memoryScaleDownThreshold) {
                    triggeringMetrics.add(String.format("Memory: %.1f%% < %.1f%%", metrics.getMemoryUsage(), memoryScaleDownThreshold));
                }
                if (metrics.getCacheHitRate() > cacheHitRateScaleDownThreshold) {
                    triggeringMetrics.add(String.format("Cache Hit Rate: %.1f%% > %.1f%%", metrics.getCacheHitRate(), cacheHitRateScaleDownThreshold));
                }
            }

            return triggeringMetrics;
        }

        private boolean isCooldownPeriodExpired() {
            LocalDateTime lastScale = lastScaleActions.values().stream()
                    .max(LocalDateTime::compareTo)
                    .orElse(LocalDateTime.now().minusSeconds(cooldownPeriodSeconds + 1));

            return lastScale.isBefore(LocalDateTime.now().minusSeconds(cooldownPeriodSeconds));
        }

        private void simulateIamScalingAction(IamScalingDecision decision) {
            log.info("Simulating IAM service scaling action: {} to {} instances",
                    decision.getAction(), decision.getTargetInstances());

            // Simulate container orchestration API calls
            if ("SCALE_UP".equals(decision.getAction())) {
                log.info("Calling orchestration API to scale up IAM service instances");
                log.info("Initializing database connection pools for new instances");
                log.info("Setting up Redis cache connections for new instances");
            } else if ("SCALE_DOWN".equals(decision.getAction())) {
                log.info("Calling orchestration API to scale down IAM service instances");
                log.info("Gracefully shutting down database connections");
                log.info("Clearing Redis cache connections for terminated instances");
            }
        }

        private void notifyScalingEvent(IamScalingDecision decision) {
            // In a real implementation, this would send notifications
            log.info("IAM scaling event notification: {}", decision);
        }

        public IamAutoScalingStatus getScalingStatus() {
            IamAutoScalingStatus status = new IamAutoScalingStatus();
            status.setCurrentInstances(currentInstanceCount.get());
            status.setMinInstances(minInstances);
            status.setMaxInstances(maxInstances);
            status.setLastScaleAction(lastScaleActions.entrySet().stream()
                    .max((e1, e2) -> e1.getValue().compareTo(e2.getValue()))
                    .map(entry -> entry.getKey() + " at " + entry.getValue())
                    .orElse("None"));
            status.setCooldownActive(!isCooldownPeriodExpired());
            return status;
        }
    }

    public class IamAutoScalingMetricsCollector {
        private final AtomicInteger requestCount = new AtomicInteger(0);
        private final AtomicInteger dbConnectionCount = new AtomicInteger(0);
        private volatile double currentCpuUsage = 0.0;
        private volatile double currentMemoryUsage = 0.0;
        private volatile double currentJvmHeapUsage = 0.0;
        private volatile double currentCacheHitRate = 0.0;

        public IamAutoScalingMetrics collectMetrics() {
            IamAutoScalingMetrics metrics = new IamAutoScalingMetrics();

            // Collect system metrics
            metrics.setCpuUsage(getCurrentCpuUsage());
            metrics.setMemoryUsage(getCurrentMemoryUsage());
            metrics.setJvmHeapUsage(getCurrentJvmHeapUsage());

            // Collect application-specific metrics
            metrics.setRequestRatePerSecond(requestCount.getAndSet(0));
            metrics.setAverageResponseTime(getCurrentAverageResponseTime());
            metrics.setDbConnectionUtilization(getCurrentDbConnectionUtilization());
            metrics.setCacheHitRate(getCurrentCacheHitRate());
            metrics.setActiveSessions(getCurrentActiveSessions());
            metrics.setAuthRatePerSecond(getCurrentAuthRate());

            metrics.setTimestamp(LocalDateTime.now());

            log.debug("Collected IAM auto-scaling metrics: {}", metrics);
            return metrics;
        }

        public void recordRequest() {
            requestCount.incrementAndGet();
        }

        public void recordAuthentication() {
            // Track authentication-specific metrics
        }

        public void recordDbConnection() {
            dbConnectionCount.incrementAndGet();
        }

        private double getCurrentCpuUsage() {
            // Simulate CPU usage with some randomness
            return Math.max(0, Math.min(100, 45 + (Math.random() - 0.5) * 35));
        }

        private double getCurrentMemoryUsage() {
            // Simulate memory usage with some randomness
            return Math.max(0, Math.min(100, 55 + (Math.random() - 0.5) * 25));
        }

        private double getCurrentJvmHeapUsage() {
            // Simulate JVM heap usage
            return Math.max(0, Math.min(100, 65 + (Math.random() - 0.5) * 20));
        }

        private long getCurrentAverageResponseTime() {
            // Simulate response time for IAM operations
            return (long) Math.max(50, 300 + (Math.random() - 0.5) * 400);
        }

        private double getCurrentDbConnectionUtilization() {
            // Simulate database connection pool utilization
            return Math.max(0, Math.min(100, 40 + (Math.random() - 0.5) * 30));
        }

        private double getCurrentCacheHitRate() {
            // Simulate cache hit rate (higher is better)
            return Math.max(0, Math.min(100, 75 + (Math.random() - 0.5) * 20));
        }

        private int getCurrentActiveSessions() {
            // Simulate active user sessions
            return (int) Math.max(10, 50 + (Math.random() - 0.5) * 80);
        }

        private int getCurrentAuthRate() {
            // Simulate authentication requests per second
            return (int) Math.max(5, 20 + (Math.random() - 0.5) * 30);
        }
    }

    public class IamScalingDecisionEngine {

        public IamScalingDecision makeDecision(IamAutoScalingMetrics metrics, IamScalingContext context) {
            IamScalingDecision decision = new IamScalingDecision();

            // Calculate composite score weighted for IAM-specific metrics
            double compositeScore = calculateIamCompositeScore(metrics);

            if (compositeScore > 0.8 && context.getCurrentInstances() < maxInstances) {
                decision.setAction("SCALE_UP");
                decision.setTargetInstances(Math.min(context.getCurrentInstances() + 1, maxInstances));
                decision.setReason("High IAM composite performance score: " + String.format("%.2f", compositeScore));
                decision.setConfidence(calculateConfidence(metrics, true));
            } else if (compositeScore < 0.3 && context.getCurrentInstances() > minInstances) {
                decision.setAction("SCALE_DOWN");
                decision.setTargetInstances(Math.max(context.getCurrentInstances() - 1, minInstances));
                decision.setReason("Low IAM composite performance score: " + String.format("%.2f", compositeScore));
                decision.setConfidence(calculateConfidence(metrics, false));
            } else {
                decision.setAction("NONE");
                decision.setReason("IAM performance score within acceptable range: " + String.format("%.2f", compositeScore));
                decision.setConfidence(0.5);
            }

            return decision;
        }

        private double calculateIamCompositeScore(IamAutoScalingMetrics metrics) {
            // Weight IAM-specific metrics more heavily
            double cpuScore = normalizeScore(metrics.getCpuUsage(), 0, 100);
            double memoryScore = normalizeScore(metrics.getMemoryUsage(), 0, 100);
            double jvmHeapScore = normalizeScore(metrics.getJvmHeapUsage(), 0, 100);
            double dbConnectionScore = normalizeScore(metrics.getDbConnectionUtilization(), 0, 100);
            double requestRateScore = normalizeScore(metrics.getRequestRatePerSecond(), 0, 300);
            double responseTimeScore = normalizeScore(metrics.getAverageResponseTime(), 50, 2000);
            double authRateScore = normalizeScore(metrics.getAuthRatePerSecond(), 0, 100);

            // Weighted scoring with emphasis on database and authentication performance
            return (cpuScore * 0.20 + memoryScore * 0.20 + jvmHeapScore * 0.15 +
                    dbConnectionScore * 0.20 + requestRateScore * 0.10 +
                    responseTimeScore * 0.10 + authRateScore * 0.05);
        }

        private double normalizeScore(double value, double min, double max) {
            return (value - min) / (max - min);
        }

        private double calculateConfidence(IamAutoScalingMetrics metrics, boolean scaleUp) {
            // Calculate confidence based on metric consistency
            return Math.max(0.5, Math.min(1.0, 0.7 + (Math.random() - 0.5) * 0.3));
        }
    }

    // Scheduled auto-scaling evaluation
    @Scheduled(fixedDelayString = "${app.auto-scaling.evaluation.interval:30000}")
    public void evaluateIamAutoScaling() {
        if (!Boolean.parseBoolean(System.getProperty("autoScaling.enabled", "true"))) {
            return;
        }

        try {
            IamAutoScalingManager manager = iamAutoScalingManager();
            IamScalingDecision decision = manager.evaluateScalingNeeds();

            if (!"NONE".equals(decision.getAction())) {
                log.info("IAM auto-scaling decision: {}", decision);
                manager.executeScalingDecision(decision);
            }

        } catch (Exception e) {
            log.error("Error during IAM auto-scaling evaluation", e);
        }
    }

    // Data classes for IAM-specific auto-scaling
    public static class IamAutoScalingMetrics {
        private double cpuUsage;
        private double memoryUsage;
        private double jvmHeapUsage;
        private int requestRatePerSecond;
        private long averageResponseTime;
        private double dbConnectionUtilization;
        private double cacheHitRate;
        private int activeSessions;
        private int authRatePerSecond;
        private LocalDateTime timestamp;

        // Getters and setters
        public double getCpuUsage() { return cpuUsage; }
        public void setCpuUsage(double cpuUsage) { this.cpuUsage = cpuUsage; }

        public double getMemoryUsage() { return memoryUsage; }
        public void setMemoryUsage(double memoryUsage) { this.memoryUsage = memoryUsage; }

        public double getJvmHeapUsage() { return jvmHeapUsage; }
        public void setJvmHeapUsage(double jvmHeapUsage) { this.jvmHeapUsage = jvmHeapUsage; }

        public int getRequestRatePerSecond() { return requestRatePerSecond; }
        public void setRequestRatePerSecond(int requestRatePerSecond) { this.requestRatePerSecond = requestRatePerSecond; }

        public long getAverageResponseTime() { return averageResponseTime; }
        public void setAverageResponseTime(long averageResponseTime) { this.averageResponseTime = averageResponseTime; }

        public double getDbConnectionUtilization() { return dbConnectionUtilization; }
        public void setDbConnectionUtilization(double dbConnectionUtilization) { this.dbConnectionUtilization = dbConnectionUtilization; }

        public double getCacheHitRate() { return cacheHitRate; }
        public void setCacheHitRate(double cacheHitRate) { this.cacheHitRate = cacheHitRate; }

        public int getActiveSessions() { return activeSessions; }
        public void setActiveSessions(int activeSessions) { this.activeSessions = activeSessions; }

        public int getAuthRatePerSecond() { return authRatePerSecond; }
        public void setAuthRatePerSecond(int authRatePerSecond) { this.authRatePerSecond = authRatePerSecond; }

        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

        @Override
        public String toString() {
            return String.format("IamAutoScalingMetrics{cpu=%.1f%%, memory=%.1f%%, jvmHeap=%.1f%%, " +
                    "reqRate=%d/s, respTime=%dms, dbConn=%.1f%%, cache=%.1f%%, sessions=%d, auth=%d/s, time=%s}",
                    cpuUsage, memoryUsage, jvmHeapUsage, requestRatePerSecond, averageResponseTime,
                    dbConnectionUtilization, cacheHitRate, activeSessions, authRatePerSecond, timestamp);
        }
    }

    public static class IamScalingDecision {
        private String action;
        private String reason;
        private int targetInstances;
        private double confidence;
        private java.util.List<String> triggeringMetrics;
        private LocalDateTime timestamp = LocalDateTime.now();

        // Getters and setters
        public String getAction() { return action; }
        public void setAction(String action) { this.action = action; }

        public String getReason() { return reason; }
        public void setReason(String reason) { this.reason = reason; }

        public int getTargetInstances() { return targetInstances; }
        public void setTargetInstances(int targetInstances) { this.targetInstances = targetInstances; }

        public double getConfidence() { return confidence; }
        public void setConfidence(double confidence) { this.confidence = confidence; }

        public java.util.List<String> getTriggeringMetrics() { return triggeringMetrics; }
        public void setTriggeringMetrics(java.util.List<String> triggeringMetrics) { this.triggeringMetrics = triggeringMetrics; }

        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

        @Override
        public String toString() {
            return String.format("IamScalingDecision{action=%s, reason='%s', target=%d, confidence=%.1f%%, " +
                    "triggers=%s, time=%s}",
                    action, reason, targetInstances, confidence * 100, triggeringMetrics, timestamp);
        }
    }

    public static class IamScalingContext {
        private int currentInstances;
        private int minInstances;
        private int maxInstances;
        private LocalDateTime lastScaleTime;

        // Getters and setters
        public int getCurrentInstances() { return currentInstances; }
        public void setCurrentInstances(int currentInstances) { this.currentInstances = currentInstances; }

        public int getMinInstances() { return minInstances; }
        public void setMinInstances(int minInstances) { this.minInstances = minInstances; }

        public int getMaxInstances() { return maxInstances; }
        public void setMaxInstances(int maxInstances) { this.maxInstances = maxInstances; }

        public LocalDateTime getLastScaleTime() { return lastScaleTime; }
        public void setLastScaleTime(LocalDateTime lastScaleTime) { this.lastScaleTime = lastScaleTime; }
    }

    public static class IamAutoScalingStatus {
        private int currentInstances;
        private int minInstances;
        private int maxInstances;
        private String lastScaleAction;
        private boolean cooldownActive;
        private LocalDateTime timestamp = LocalDateTime.now();

        // Getters and setters
        public int getCurrentInstances() { return currentInstances; }
        public void setCurrentInstances(int currentInstances) { this.currentInstances = currentInstances; }

        public int getMinInstances() { return minInstances; }
        public void setMinInstances(int minInstances) { this.minInstances = minInstances; }

        public int getMaxInstances() { return maxInstances; }
        public void setMaxInstances(int maxInstances) { this.maxInstances = maxInstances; }

        public String getLastScaleAction() { return lastScaleAction; }
        public void setLastScaleAction(String lastScaleAction) { this.lastScaleAction = lastScaleAction; }

        public boolean isCooldownActive() { return cooldownActive; }
        public void setCooldownActive(boolean cooldownActive) { this.cooldownActive = cooldownActive; }

        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

        @Override
        public String toString() {
            return String.format("IamAutoScalingStatus{current=%d, min=%d, max=%d, lastScale='%s', " +
                    "cooldown=%s, time=%s}",
                    currentInstances, minInstances, maxInstances, lastScaleAction, cooldownActive, timestamp);
        }
    }

    private static class IamMetricsCollector {
        public IamAutoScalingMetrics collectMetrics() {
            IamAutoScalingMetrics metrics = new IamAutoScalingMetrics();

            // Simulate metrics collection for IAM service
            metrics.setCpuUsage(Math.random() * 100);
            metrics.setMemoryUsage(Math.random() * 100);
            metrics.setJvmHeapUsage(Math.random() * 100);
            metrics.setRequestRatePerSecond((int) (Math.random() * 300));
            metrics.setAverageResponseTime((long) (Math.random() * 2000));
            metrics.setDbConnectionUtilization(Math.random() * 100);
            metrics.setCacheHitRate(Math.random() * 100);
            metrics.setActiveSessions((int) (Math.random() * 150));
            metrics.setAuthRatePerSecond((int) (Math.random() * 100));
            metrics.setTimestamp(LocalDateTime.now());

            return metrics;
        }
    }
}