# ==============================
# SERVER CONFIGURATION
# ==============================
server.port=7070
server.servlet.context-path=/

# ==============================
# SPRING APPLICATION CONFIG
# ==============================
spring.application.name=gateway-service
spring.profiles.active=dev

# Disable Spring Cloud compatibility check for Spring Boot 3.5.6
spring.cloud.compatibility-verifier.enabled=false

# ==============================
# REDIS CONFIGURATION
# ==============================
spring.redis.host = ${REDIS_HOST:localhost}
spring.redis.port = ${REDIS_PORT:6379}
spring.redis.password = ${REDIS_PASSWORD:}
spring.redis.timeout = 2000ms
spring.redis.lettuce.pool.max-active = 8
spring.redis.lettuce.pool.max-idle = 8
spring.redis.lettuce.pool.min-idle = 0

# ==============================
# CIRCUIT BREAKER CONFIGURATION
# ==============================
resilience4j.circuitbreaker:
  configs:
    default:
      registerHealthIndicator: true
      slidingWindowSize: 10
      minimumNumberOfCalls: 5
      permittedNumberOfCallsInHalfOpenState: 3
      automaticTransitionFromOpenToHalfOpenEnabled: true
      waitDurationInOpenState: 30s
      failureRateThreshold: 50%
      slowCallDurationThreshold: 3s
      slowCallRateThreshold: 60%
  instances:
    iam-service:
      baseConfig: default
      failureRateThreshold: 50
      waitDurationInOpenState: 30s
      slidingWindowSize: 10
      minimumNumberOfCalls: 5
      permittedNumberOfCallsInHalfOpenState: 3
      slowCallDurationThreshold: 2s
      slowCallRateThreshold: 60%
    user-service:
      baseConfig: default
      failureRateThreshold: 60
      waitDurationInOpenState: 45s
      slidingWindowSize: 8
      minimumNumberOfCalls: 4
    auth-service:
      baseConfig: default
      failureRateThreshold: 40
      waitDurationInOpenState: 20s
      slidingWindowSize: 15
      minimumNumberOfCalls: 8
    email-service:
      baseConfig: default
      failureRateThreshold: 70
      waitDurationInOpenState: 60s
      slidingWindowSize: 5
      minimumNumberOfCalls: 3
    notification-service:
      baseConfig: default
      failureRateThreshold: 65
      waitDurationInOpenState: 45s
      slidingWindowSize: 6
      minimumNumberOfCalls: 4

# ==============================
# RETRY CONFIGURATION
# ==============================
resilience4j.retry:
  configs:
    default:
      maxAttempts: 3
      waitDuration: 1s
      retryExceptions:
        - org.springframework.web.client.HttpServerErrorException
        - java.util.concurrent.TimeoutException
        - io.github.resilience4j.circuitbreaker.CallNotPermittedException
  instances:
    iam-service-retry:
      baseConfig: default
      maxAttempts: 3
      waitDuration: 1s
    auth-service-retry:
      baseConfig: default
      maxAttempts: 2
      waitDuration: 500ms
    email-service-retry:
      baseConfig: default
      maxAttempts: 1
      waitDuration: 2s

# ==============================
# TIME LIMITER CONFIGURATION
# ==============================
resilience4j.timelimiter:
  configs:
    default:
      timeoutDuration: 5s
      cancelRunningFuture: true
  instances:
    iam-service:
      timeoutDuration: 3s
    auth-service:
      timeoutDuration: 2s
    user-service:
      timeoutDuration: 4s
    email-service:
      timeoutDuration: 10s
    notification-service:
      timeoutDuration: 8s

# ==============================
# RATE LIMITING CONFIGURATION
# ==============================
spring.cloud.gateway.filter.request-rate-limiter:
  enabled: true

# ==============================
# SERVICE URLS
# ==============================
iam.service.url = ${IAM_SERVICE_URL:http://localhost:8081}

# ==============================
# SECURITY HEADERS
# ==============================
spring.cloud.gateway.filter.remove-request-header:
  - Cookie
  - Set-Cookie

spring.cloud.gateway.filter.add-response-header:
  - X-Content-Type-Options=nosniff
  - X-Frame-Options=DENY
  - X-XSS-Protection=1; mode=block
  - Strict-Transport-Security=max-age=31536000; includeSubDomains

# ==============================
# ACTUATOR / MANAGEMENT
# ==============================
management.endpoints.web.exposure.include = health,info,metrics,prometheus,gateway
management.endpoint.health.show-details = always
management.endpoint.gateway.enabled = true
management.metrics.export.prometheus.enabled = true

# ==============================
# TIMEOUT CONFIGURATION
# ==============================
spring.cloud.gateway.httpclient.connect-timeout = 5000
spring.cloud.gateway.httpclient.response-timeout = 30s
spring.cloud.gateway.httpclient.pool.max-connections = 500
spring.cloud.gateway.httpclient.pool.acquire-timeout = 30000

# ==============================
# LOGGING
# ==============================
logging.level.org.springframework.cloud.gateway = DEBUG
logging.level.org.springframework.web.reactive = DEBUG
logging.pattern.console = %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# ==============================
# SPRING CLOUD GATEWAY ROUTES
# ==============================
# Routes are configured via Java code in GatewayConfig.java
# to avoid conflicts between multiple configuration sources

# ==============================
# LOAD BALANCING CONFIGURATION
# ==============================
app.load-balancing.enabled = true
app.load-balancing.strategy = round-robin
app.load-balancing.health-check.enabled = true
app.load-balancing.health-check.interval = 30000
app.load-balancing.circuit-breaker-aware.enabled = true

# Load Balancing Service Weights (if using weighted strategy)
app.load-balancing.services.iam-service.instances[0].weight = 3
app.load-balancing.services.iam-service.instances[1].weight = 2
app.load-balancing.services.user-service.instances[0].weight = 2
app.load-balancing.services.user-service.instances[1].weight = 1

# ==============================
# SERVICE DISCOVERY CONFIGURATION
# ==============================
spring.cloud.discovery.enabled = true
spring.cloud.consul.enabled = false
spring.cloud.consul.host = ${CONSUL_HOST:localhost}
spring.cloud.consul.port = ${CONSUL_PORT:8500}
spring.cloud.consul.discovery.service-name = gateway-service
spring.cloud.consul.discovery.prefer-ip-address = true
spring.cloud.consul.health-check.interval = 10s
spring.cloud.consul.health-check.timeout = 5s

# # ---------- Vendor Service ----------
# spring.cloud.gateway.routes[1].id=vendor-service
# spring.cloud.gateway.routes[1].uri=http://vendor-service:3001
# spring.cloud.gateway.routes[1].predicates[0]=Path=/api/vendors/**
# spring.cloud.gateway.routes[1].filters[0]=StripPrefix=1
# spring.cloud.gateway.routes[1].filters[1].name=AuthenticationFilter
# spring.cloud.gateway.routes[1].filters[2].name=CircuitBreaker
# spring.cloud.gateway.routes[1].filters[2].args.name=vendor-service
# spring.cloud.gateway.routes[1].filters[2].args.fallbackUri=forward:/fallback/vendor

# ==============================
# AUTO-SCALING CONFIGURATION
# ==============================
app.auto-scaling.enabled = true
app.auto-scaling.evaluation.interval = 30000

# Instance Limits
app.auto-scaling.min.instances = 2
app.auto-scaling.max.instances = 10

# CPU Thresholds (percentage)
app.auto-scaling.cpu.threshold.scale-up = 70
app.auto-scaling.cpu.threshold.scale-down = 30

# Memory Thresholds (percentage)
app.auto-scaling.memory.threshold.scale-up = 80
app.auto-scaling.memory.threshold.scale-down = 40

# Request Rate Thresholds (requests per second)
app.auto-scaling.request-rate.threshold.scale-up = 100
app.auto-scaling.request-rate.threshold.scale-down = 20

# Response Time Thresholds (milliseconds)
app.auto-scaling.response-time.threshold.scale-up = 2000
app.auto-scaling.response-time.threshold.scale-down = 500

# Cooldown Period (seconds)
app.auto-scaling.cooldown-period = 300

# Auto-scaling Strategy Configuration
app.auto-scaling.strategy = composite-metrics
app.auto-scaling.decision-engine = weighted-composite
app.auto-scaling.metrics.window = 60
app.auto-scaling.prediction.enabled = false

# Advanced Auto-scaling Settings
app.auto-scaling.graceful-shutdown.enabled = true
app.auto-scaling.health-check.during-scaling = true
app.auto-scaling.rolling-update.enabled = true
app.auto-scaling.prediction.model = linear-regression

# Auto-scaling Metrics Collection
app.auto-scaling.metrics.collection.enabled = true
app.auto-scaling.metrics.retention.hours = 168
app.auto-scaling.metrics.aggregation.interval = 10

# Auto-scaling Notifications
app.auto-scaling.notifications.enabled = true
app.auto-scaling.notifications.channels = webhook,email
app.auto-scaling.notifications.webhook.url = ${WEBHOOK_URL:http://localhost:8080/webhooks/autoscaling}

# # ---------- Product Catalog ----------
# spring.cloud.gateway.routes[2].id=product-catalog
# spring.cloud.gateway.routes[2].uri=http://product-catalog:3002
# spring.cloud.gateway.routes[2].predicates[0]=Path=/api/products/**
# spring.cloud.gateway.routes[2].filters[0]=StripPrefix=1
# spring.cloud.gateway.routes[2].filters[1].name=AuthenticationFilter
# spring.cloud.gateway.routes[2].filters[2].name=CircuitBreaker
# spring.cloud.gateway.routes[2].filters[2].args.name=product-catalog
# spring.cloud.gateway.routes[2].filters[2].args.fallbackUri=forward:/fallback/products

# # ---------- Inventory Service ----------
# spring.cloud.gateway.routes[3].id=inventory-service
# spring.cloud.gateway.routes[3].uri=http://inventory-service:8081
# spring.cloud.gateway.routes[3].predicates[0]=Path=/api/inventory/**
# spring.cloud.gateway.routes[3].filters[0]=StripPrefix=1
# spring.cloud.gateway.routes[3].filters[1].name=AuthenticationFilter
# spring.cloud.gateway.routes[3].filters[2].name=CircuitBreaker
# spring.cloud.gateway.routes[3].filters[2].args.name=inventory-service
# spring.clo
