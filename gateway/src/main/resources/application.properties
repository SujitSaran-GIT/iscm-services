# ==============================
# SERVER CONFIGURATION - OPTIMIZED
# ==============================
server.port=7070
server.servlet.context-path=/

# Tomcat thread pool optimization
server.tomcat.threads.min-spare=20
server.tomcat.threads.max=200
server.tomcat.accept-count=100
server.tomcat.connection-timeout=5000
server.tomcat.max-connections=10000

# HTTP keep-alive settings
server.tomcat.keep-alive-timeout=30
server.tomcat.max-keep-alive-requests=100

# ==============================
# SPRING APPLICATION CONFIG
# ==============================
spring.application.name=gateway-service
spring.profiles.active=dev

# Disable Spring Cloud compatibility check for Spring Boot 3.5.6
spring.cloud.compatibility-verifier.enabled=false

# ==============================
# REDIS CONFIGURATION - DISABLED
# ==============================
# spring.redis.host = ${REDIS_HOST:localhost}
# spring.redis.port = ${REDIS_PORT:6379}
# spring.redis.password = ${REDIS_PASSWORD:}
# spring.redis.timeout = 1000ms
# spring.redis.lettuce.pool.max-active = 15
# spring.redis.lettuce.pool.max-idle = 10
# spring.redis.lettuce.pool.min-idle = 5
# spring.redis.lettuce.pool.max-wait = 2000ms
# spring.redis.lettuce.shutdown-timeout = 200ms

# ==============================
# CIRCUIT BREAKER CONFIGURATION - DISABLED
# ==============================
# resilience4j.circuitbreaker:
#   configs:
#     default:
#       registerHealthIndicator: true
#       slidingWindowSize: 20
#       minimumNumberOfCalls: 10
#       permittedNumberOfCallsInHalfOpenState: 5
#       automaticTransitionFromOpenToHalfOpenEnabled: true
#       waitDurationInOpenState: 60s
#       failureRateThreshold: 40%
#       slowCallDurationThreshold: 1s
#       slowCallRateThreshold: 50%
#   instances:
#     iam-service:
#       baseConfig: default
#       failureRateThreshold: 70
#       waitDurationInOpenState: 10s
#       slidingWindowSize: 20
#       minimumNumberOfCalls: 15
#       permittedNumberOfCallsInHalfOpenState: 10
#       slowCallDurationThreshold: 2s
#       slowCallRateThreshold: 60%
#     user-service:
#       baseConfig: default
#       failureRateThreshold: 50
#       waitDurationInOpenState: 45s
#       slidingWindowSize: 15
#       minimumNumberOfCalls: 8
#       slowCallDurationThreshold: 1.5s
#     auth-service:
#       baseConfig: default
#       failureRateThreshold: 35
#       waitDurationInOpenState: 30s
#       slidingWindowSize: 20
#       minimumNumberOfCalls: 10
#       slowCallDurationThreshold: 800ms
#     email-service:
#       baseConfig: default
#       failureRateThreshold: 60
#       waitDurationInOpenState: 45s
#       slidingWindowSize: 10
#       minimumNumberOfCalls: 5
#       slowCallDurationThreshold: 3s
#     notification-service:
#       baseConfig: default
#       failureRateThreshold: 55
#       waitDurationInOpenState: 30s
#       slidingWindowSize: 12
#       minimumNumberOfCalls: 6

# ==============================
# RETRY CONFIGURATION - OPTIMIZED
# ==============================
resilience4j.retry:
  configs:
    default:
      maxAttempts: 2
      waitDuration: 500ms
      retryExceptions:
        - org.springframework.web.client.HttpServerErrorException
        - java.util.concurrent.TimeoutException
  instances:
    iam-service-retry:
      baseConfig: default
      maxAttempts: 2
      waitDuration: 500ms
    auth-service-retry:
      baseConfig: default
      maxAttempts: 2
      waitDuration: 300ms
    email-service-retry:
      baseConfig: default
      maxAttempts: 1
      waitDuration: 1000ms
    user-service-retry:
      baseConfig: default
      maxAttempts: 2
      waitDuration: 400ms

# ==============================
# TIME LIMITER CONFIGURATION - OPTIMIZED
# ==============================
resilience4j.timelimiter:
  configs:
    default:
      timeoutDuration: 8s
      cancelRunningFuture: true
  instances:
    iam-service:
      timeoutDuration: 5s
    auth-service:
      timeoutDuration: 3s
    user-service:
      timeoutDuration: 4s
    email-service:
      timeoutDuration: 12s
    notification-service:
      timeoutDuration: 10s

# ==============================
# RATE LIMITING CONFIGURATION - DISABLED
# ==============================
spring.cloud.gateway.filter.request-rate-limiter:
  enabled: false

# ==============================
# SERVICE URLS
# ==============================
iam.service.url = ${IAM_SERVICE_URL:http://localhost:8081}

# ==============================
# CORS CONFIGURATION - OPTIMIZED
# ==============================
cors.allowed.origins=${CORS_ALLOWED_ORIGINS:http://localhost:5173,http://localhost:5174,http://127.0.0.1:5173,http://127.0.0.1:5174}

# ==============================
# SECURITY HEADERS
# ==============================
spring.cloud.gateway.filter.remove-request-header:
  - Cookie
  - Set-Cookie

spring.cloud.gateway.filter.add-response-header:
  - X-Content-Type-Options=nosniff
  - X-Frame-Options=DENY
  - X-XSS-Protection=1; mode=block
  - Strict-Transport-Security=max-age=31536000; includeSubDomains

# ==============================
# ACTUATOR / MANAGEMENT - ENHANCED MONITORING
# ==============================
management.endpoints.web.exposure.include = health,info,metrics,prometheus,gateway
management.endpoint.health.show-details = always
management.endpoint.gateway.enabled = true
management.metrics.export.prometheus.enabled = true
management.metrics.enabled = true

# Enhanced metrics collection
management.metrics.tags.application=iscm-gateway
management.metrics.export.simple.enabled=true
management.metrics.distribution.percentiles-histogram.http.server.requests=true
management.metrics.distribution.sla.http.server.requests=10ms,50ms,100ms,200ms,500ms,1s,2s,5s

# Gateway specific metrics
spring.cloud.gateway.actuator.verbose.enabled=true
spring.cloud.gateway.filter.add-request-header=X-Gateway-Metrics=true

# ==============================
# TIMEOUT CONFIGURATION - OPTIMIZED
# ==============================
spring.cloud.gateway.httpclient.connect-timeout = 2000
spring.cloud.gateway.httpclient.response-timeout = 10s
spring.cloud.gateway.httpclient.pool.max-connections = 1000
spring.cloud.gateway.httpclient.pool.acquire-timeout = 5000
spring.cloud.gateway.httpclient.pool.max-idle-time = 60s
spring.cloud.gateway.httpclient.pool.time-to-live = 60s

# ==============================
# LOGGING
# ==============================
logging.level.org.springframework.cloud.gateway = DEBUG
logging.level.org.springframework.web.reactive = DEBUG
logging.pattern.console = %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# ==============================
# SPRING CLOUD GATEWAY ROUTES
# ==============================
# Routes are configured via Java code in GatewayConfig.java
# to avoid conflicts between multiple configuration sources

# ==============================
# LOAD BALANCING CONFIGURATION
# ==============================
app.load-balancing.enabled = true
app.load-balancing.strategy = round-robin
app.load-balancing.health-check.enabled = true
app.load-balancing.health-check.interval = 30000
app.load-balancing.circuit-breaker-aware.enabled = true

# Load Balancing Service Weights (if using weighted strategy)
app.load-balancing.services.iam-service.instances[0].weight = 3
app.load-balancing.services.iam-service.instances[1].weight = 2
app.load-balancing.services.user-service.instances[0].weight = 2
app.load-balancing.services.user-service.instances[1].weight = 1

# ==============================
# SERVICE DISCOVERY CONFIGURATION
# ==============================
spring.cloud.discovery.enabled = true
spring.cloud.consul.enabled = false
spring.cloud.consul.host = ${CONSUL_HOST:localhost}
spring.cloud.consul.port = ${CONSUL_PORT:8500}
spring.cloud.consul.discovery.service-name = gateway-service
spring.cloud.consul.discovery.prefer-ip-address = true
spring.cloud.consul.health-check.interval = 10s
spring.cloud.consul.health-check.timeout = 5s

# # ---------- Vendor Service ----------
# spring.cloud.gateway.routes[1].id=vendor-service
# spring.cloud.gateway.routes[1].uri=http://vendor-service:3001
# spring.cloud.gateway.routes[1].predicates[0]=Path=/api/vendors/**
# spring.cloud.gateway.routes[1].filters[0]=StripPrefix=1
# spring.cloud.gateway.routes[1].filters[1].name=AuthenticationFilter
# spring.cloud.gateway.routes[1].filters[2].name=CircuitBreaker
# spring.cloud.gateway.routes[1].filters[2].args.name=vendor-service
# spring.cloud.gateway.routes[1].filters[2].args.fallbackUri=forward:/fallback/vendor

# ==============================
# AUTO-SCALING CONFIGURATION
# ==============================
app.auto-scaling.enabled = true
app.auto-scaling.evaluation.interval = 30000

# Instance Limits
app.auto-scaling.min.instances = 2
app.auto-scaling.max.instances = 10

# CPU Thresholds (percentage)
app.auto-scaling.cpu.threshold.scale-up = 70
app.auto-scaling.cpu.threshold.scale-down = 30

# Memory Thresholds (percentage)
app.auto-scaling.memory.threshold.scale-up = 80
app.auto-scaling.memory.threshold.scale-down = 40

# Request Rate Thresholds (requests per second)
app.auto-scaling.request-rate.threshold.scale-up = 100
app.auto-scaling.request-rate.threshold.scale-down = 20

# Response Time Thresholds (milliseconds)
app.auto-scaling.response-time.threshold.scale-up = 2000
app.auto-scaling.response-time.threshold.scale-down = 500

# Cooldown Period (seconds)
app.auto-scaling.cooldown-period = 300

# Auto-scaling Strategy Configuration
app.auto-scaling.strategy = composite-metrics
app.auto-scaling.decision-engine = weighted-composite
app.auto-scaling.metrics.window = 60
app.auto-scaling.prediction.enabled = false

# Advanced Auto-scaling Settings
app.auto-scaling.graceful-shutdown.enabled = true
app.auto-scaling.health-check.during-scaling = true
app.auto-scaling.rolling-update.enabled = true
app.auto-scaling.prediction.model = linear-regression

# Auto-scaling Metrics Collection
app.auto-scaling.metrics.collection.enabled = true
app.auto-scaling.metrics.retention.hours = 168
app.auto-scaling.metrics.aggregation.interval = 10

# Auto-scaling Notifications
app.auto-scaling.notifications.enabled = true
app.auto-scaling.notifications.channels = webhook,email
app.auto-scaling.notifications.webhook.url = ${WEBHOOK_URL:http://localhost:8080/webhooks/autoscaling}

# # ---------- Product Catalog ----------
# spring.cloud.gateway.routes[2].id=product-catalog
# spring.cloud.gateway.routes[2].uri=http://product-catalog:3002
# spring.cloud.gateway.routes[2].predicates[0]=Path=/api/products/**
# spring.cloud.gateway.routes[2].filters[0]=StripPrefix=1
# spring.cloud.gateway.routes[2].filters[1].name=AuthenticationFilter
# spring.cloud.gateway.routes[2].filters[2].name=CircuitBreaker
# spring.cloud.gateway.routes[2].filters[2].args.name=product-catalog
# spring.cloud.gateway.routes[2].filters[2].args.fallbackUri=forward:/fallback/products

# # ---------- Inventory Service ----------
# spring.cloud.gateway.routes[3].id=inventory-service
# spring.cloud.gateway.routes[3].uri=http://inventory-service:8081
# spring.cloud.gateway.routes[3].predicates[0]=Path=/api/inventory/**
# spring.cloud.gateway.routes[3].filters[0]=StripPrefix=1
# spring.cloud.gateway.routes[3].filters[1].name=AuthenticationFilter
# spring.cloud.gateway.routes[3].filters[2].name=CircuitBreaker
# spring.cloud.gateway.routes[3].filters[2].args.name=inventory-service
# spring.clo
